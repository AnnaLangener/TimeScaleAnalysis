---
title: "Temporal Resultion: Aggregation & Rolling Window"
output: 
    rmarkdown::html_document:
    theme: lumen
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library('dplyr')
library('ggplot2')
library('plotly')
library("runner")
library("hrbrthemes")
library("viridis")
library("ggpubr")
library("tidyr")
library("knitr")
library("dotwhisker")
library("stargazer")
library("lme4")

###### Load dataframes #########
################################

##### Interaction data  #####
Interactions <- read.csv('/Users/annalangener/Nextcloud/BEHAPP data/Interactions.csv') # created with IMPORTANT Social context python script
passive <- read.csv('/Users/annalangener/Nextcloud/BEHAPP data/TotalSocial.csv') #created with timescale function

BEHAPP_ID = c(117113,117114,117119,117121,117130,117129,117131,117134,117135,117137)

passive = passive[passive$ParticipantNumber %in% BEHAPP_ID,]

IntPerDay = Interactions[Interactions$time_scale == 'per day',]
IntPerDay$Date <- as.Date(IntPerDay$Date)

passiveDay = passive[passive$timescale_index == 'per day',]
passiveDay$Date <- as.Date(passiveDay$Date)
passiveDay$index_time <- as.Date(passiveDay$index_time)


PerDay <- right_join(passiveDay, IntPerDay, by = c("ParticipantNumber" = "BEHAPP_ID","index_time" = "Date"),suffix = c("",""))
PerWeek <- full_join(passive[passive$timescale_index == "per week",], Interactions[Interactions$time_scale == "per week",],  by = c("ParticipantNumber" = "BEHAPP_ID","index_time" = "Date"),suffix = c("",""))
PerStudy <- full_join(passive[passive$timescale_index == "per study",], Interactions[Interactions$time_scale == "per study",], by = c("ParticipantNumber" = "BEHAPP_ID"),suffix = c("",""))


####### Affect data #######
Affect_Passive <- read.csv("/Users/annalangener/Nextcloud/BEHAPP data/FullDataset_220422.csv")
Affect_Passive <- Affect_Passive[Affect_Passive$questionListName != "Morning assessment 1" & Affect_Passive$questionListName != "Morning Assessment",]


### Labeled following sensors as missing:
# Apps (whole day without app usage)
# Location (whole day without GPS coordinates, based on raw GPS)
# Wifi (whole day without wifi data)
# Bluetooth (whole day without Bluetooth data)

Affect_Passive_allsensor_NA <- Affect_Passive

Affect_Passive_allsensor_NA[is.na(Affect_Passive$APP_USAGE_min) | is.na(Affect_Passive$TIME_STATIONARY_min) | is.na(Affect_Passive$TOTAL_MACHASHES_number) | is.na(Affect_Passive$BLUETOOTH_TOTAL_MACHASHES_number),!colnames(Affect_Passive_allsensor_NA) %in% c("ParticipantNumber","Date", "pa_mean", "na_mean", "timescale_beforeESM")] <- NA

Affect_Passive_no_NA <- Affect_Passive

Affect_Passive_no_NA[is.na(Affect_Passive_no_NA)] <- 0
```

### Example 1 - Level of Aggregation
In this example we test whether the level of aggregation matters

#### Affect & Passive Measure (CHANGE DESCREPTIVE PLOTS)

Descriptive Plots

```{r eval=FALSE, include=FALSE}
Affect_Passive_subset$timescale_beforeESM <- ordered(Affect_Passive_subset$timescale_beforeESM,levels = c("1h","3h","6h","9h","12h","24h"))

ggplot(Affect_Passive_subset, aes(x=timescale_beforeESM, y=Cluster_HOME_min)) + 
  geom_violin(trim=FALSE, width = 1) +
  geom_boxplot(width=0.01) +
  theme_minimal()

```

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(scales)
shinyApp(
  ui = fluidPage(
    selectInput(
      "PassiveMeasure",
      label = "Passive Measure: ",
       choices = c(
          'SOCIAL_min',
           'COMMUNICATION_min',
           'APP_USAGE_min',
           'APPS_OPENED_number',
           'Cluster_HOME_min',
           "Cluster_1_min",
           "Cluster_2_min",
           "Cluster_3_min",
           "Cluster_4_min",
           "Cluster_5_min" ,
           'UNIQUE_STAYPOINTS_number',
           'TIME_STATIONARY_min',
           'TOTAL_MACHASHES_number',
           'UNIQUE_MACHASHES_number',
           "BLUETOOTH_TOTAL_MACHASHES_number",
           "BLUETOOTH_UNIQUE_MACHASHES_number",
           'CALL_TOTAL_min',
           "CALL_incoming_min",
           "CALL_outgoing_min",
           "CALL_TOTAL_number",                                                   
           "CALL_incoming_number",                                                
           "CALL_outgoing_number",                                               
           "CALL_UNIQUE_CONTACTS_number",                                         
           "LIGHT_LUX_mean",                                                      
           "LIGHT_LUX_std",                                                       
           "SCREEN_onLocked_number" ,                                             
           "SCREEN_onUnlocked_number", 
           "SMS_received_number" ,                                                
           "SMS_sent_number" ,                                                    
           "SMS_UNIQUE_CONTACTS_number" 
      ),
      selected = "Cluster_HOME_min"
    ),
    selectInput(
      "Affect",
      label = "Affect: ",
      choices = c(
        'pa_mean',
        'na_mean'
      ),
      selected = "pa_mean"
    ),
    selectInput(
      "BEHAPP_ID",
      label = "Participant Number: ",
      choices = c(117113,117114,117119,117121,117130,117129,117131,117134,117135,117137),
      selected = c(117119,117130,117134),
      multiple = TRUE
    ),
    plotOutput("Plot")
  ),
  
  server = function(input, output) {
    toListen <- reactive({
    list(input$PassiveMeasure,input$BEHAPP_ID,input$Affect)
  })
    observeEvent(toListen(), {
      Passive = input$PassiveMeasure
      Feature <- input$Affect
      counter = 0
      
      BEHAPP_ID = input$BEHAPP_ID

      #copy stuff for plot
      Affect_Passive[,"Passivecopy"] <- Affect_Passive[,colnames(Affect_Passive) == Passive]
      Affect_Passive[,"Featurecopy"] <- Affect_Passive[,colnames(Affect_Passive) == Feature]
      
      Affect_Passive$timescale_beforeESM_num <- recode(Affect_Passive$timescale_beforeESM, "1h" = 1, "3h" = 3,"6h" = 6,"9h" = 9,"12h" = 12, "24h" = 24 )
         
      max = max(Affect_Passive[,"Featurecopy"], na.rm = TRUE)
      maxy = max(Affect_Passive[,"Passivecopy"],na.rm = TRUE)
      
      if(max > maxy){
        scaleplot = 0.1*maxy
      }else{
        scaleplot = (maxy/max)
      }
      
      output$Plot = renderPlot({
          ggplot(Affect_Passive[Affect_Passive$ParticipantNumber %in% BEHAPP_ID,], aes(x = as.POSIXct(Date)))+
            geom_line(aes(y = Passivecopy, color = as.factor(timescale_beforeESM))) +
            geom_line(aes(y = Featurecopy*scaleplot), color ="#f95d6a") +
            scale_color_manual(
              values = c(
                "#90F1B3",
                "#255e7e",
                "#3CD8DA",
                "#5383a1",
                "#3CD8DA",
                "#7faac6",
                "#218CB3",
                "#abd2ec",
                "#c1e7ff"
              )
            ) +
          scale_x_datetime(labels = date_format("%m-%d"), date_breaks = "1 week") +
            ylab(Passive) +
            theme_minimal() +
            scale_y_continuous(
              name = paste(Passive),
              limits = c(0, maxy),
              sec.axis = sec_axis( ~ . / scaleplot, name = 'Affect')
            ) +
            facet_wrap( ~ ParticipantNumber, ncol = 2, scales = 'free')
        
      },  height = 500, width = 800)
      
    })
  },
  options = list(height = 780, width = 820)
)
```

#### Correlations

Webb, S. S., & Demeyere, N. (2021, July 21). Multiverse Analysis: A Method to Determine Researcher Degrees of Freedom in Test Validation. https://doi.org/10.31234/osf.io/nhrwq

"Following Simonsohn et al. (2020), the p-value for significance of a difference between medians from the observed and null effects multiverse was extracted by calculating the proportion of the 500 permutated null analyses which had a test statistic that was the exact same median value or greater as in the observed data, and divided that by two (significant if below.<05 or if no null values are equal or greater we report p <.002). For this median comparison we rounded median coefficients to two decimal places to maximize the chance of matching medians rather than inflating the risk of non-matching medians if they are >.001 decimal place out."

- Bring data in wide format
- Shuffle outcome variable with replacement across columns
- check if there is a sign. result for 3h,6h,9h,12h


Other strategy:
- Simulate Data under H0 (ysim = y-correlation coefficient), shuffle dataset with replacement


How can correlation be missing on broader time scales?
- bluetooth connections do always have the same value --> 1 and only once 0 (rest is labeled as missing)

```{r eval=FALSE, include=FALSE}
source("Calculation Correlation.R")

# Missing values labeled single sensor specific
CorrelationSampleTrue <- calculateCorr_pa(Affect_Passive)
CorrelationSampleTrue_na <- calculateCorr_na(Affect_Passive)

# If one sensor is missing, all are missing
CorrelationSampleTrue_allNA <- calculateCorr_pa(Affect_Passive_allsensor_NA)
CorrelationSampleTrue_allNA$diff <- abs(CorrelationSampleTrue$Correlation - CorrelationSampleTrue_allNA$Correlation)

CorrelationSampleTrue_allNA$diff_sign = ""
CorrelationSampleTrue_allNA$diff_sign[CorrelationSampleTrue$sign != CorrelationSampleTrue_allNA$sign] = "x"


CorrelationSampleTrue_na_allNA <- calculateCorr_na(Affect_Passive_allsensor_NA)
CorrelationSampleTrue_na_allNA$diff <- abs(CorrelationSampleTrue_na$Correlation - CorrelationSampleTrue_na_allNA$Correlation)

CorrelationSampleTrue_na_allNA$diff_sign = ""
CorrelationSampleTrue_na_allNA$diff_sign[CorrelationSampleTrue_na$sign != CorrelationSampleTrue_na_allNA$sign] = "x"

# No missing values labeled
CorrelationSampleTrue_noNA <- calculateCorr_pa(Affect_Passive_no_NA)
CorrelationSampleTrue_noNA$diff <- abs(CorrelationSampleTrue$Correlation - CorrelationSampleTrue_noNA$Correlation)

CorrelationSampleTrue_noNA$diff_sign = ""
CorrelationSampleTrue_noNA$diff_sign[CorrelationSampleTrue$sign != CorrelationSampleTrue_noNA$sign] = "x"

CorrelationSampleTrue_na_noNA <- calculateCorr_na(Affect_Passive_no_NA)
CorrelationSampleTrue_na_noNA$diff <- abs(CorrelationSampleTrue_na$Correlation - CorrelationSampleTrue_na_noNA$Correlation)

CorrelationSampleTrue_na_noNA$diff_sign = ""
CorrelationSampleTrue_na_noNA$diff_sign[CorrelationSampleTrue_na$sign != CorrelationSampleTrue_na_noNA$sign] = "x"



```

```{r eval=FALSE, include=FALSE}

### Always check if ordered factor is correct ####

#### PLOT FOR PAPER
      cor1 =  ggplot(CorrelationSampleTrue[CorrelationSampleTrue$ParticipantNumber %in% c(117119,117130,117134,"Overall"),],
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = Correlation
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = star), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Correlations between mean positive affect and passive measures")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
  theme(axis.text.y = element_text(size= 12))  
    
 cor2 =  ggplot(CorrelationSampleTrue_allNA[CorrelationSampleTrue_allNA$ParticipantNumber %in% c(117119,117130,117134,"Overall"),],
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = diff
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = diff_sign), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Difference between omitting values sensor specific and non-sensor specific")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
   labs(fill="Difference") +
  theme(axis.text.y = element_text(size= 12))  
 
 
 

      cor3 =  ggplot(CorrelationSampleTrue_noNA[CorrelationSampleTrue_noNA$ParticipantNumber %in% c(117119,117130,117134,"Overall"),],
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = diff
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = diff_sign), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Difference between omitting values sensor specific and ignoring missing values")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
        labs(fill="Difference") +
  theme(axis.text.y = element_text(size= 12))  
      
plot <- ggarrange(cor2,cor3,nrow =2, ncol = 1)

ggsave(
  "Correlation.jpg",
  plot = cor1,
  width = 28,
  height = 10,
  units = c("cm"),
  dpi = 300,
  limitsize = TRUE,
  bg = NULL)

ggsave(
  "Correlation_diff.jpg",
  plot = plot,
  width = 28,
  height = 20,
  units = c("cm"),
  dpi = 300,
  limitsize = TRUE,
  bg = NULL)


 cor4 =  ggplot(CorrelationSampleTrue_na[CorrelationSampleTrue_na$ParticipantNumber %in% c(117119,117130,117134,"Overall"),],
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = Correlation
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = star), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Correlations between mean negative affect and passive measures")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
  theme(axis.text.y = element_text(size= 12))  
 
 
 cor5 =  ggplot(CorrelationSampleTrue_na_allNA[CorrelationSampleTrue_na_allNA$ParticipantNumber %in% c(117119,117130,117134,"Overall"),],
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = diff
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = diff_sign), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Difference between omitting values sensor specific and non-sensor specific")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
   labs(fill="Difference") +
  theme(axis.text.y = element_text(size= 12))  
 
 
 

      cor6 =  ggplot(CorrelationSampleTrue_na_noNA[CorrelationSampleTrue_na_noNA$ParticipantNumber %in% c(117119,117130,117134,"Overall"),],
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = diff
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = diff_sign), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Difference between omitting values sensor specific and ignoring missing values")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
        labs(fill="Difference") +
  theme(axis.text.y = element_text(size= 12))  
      
plot_na <- ggarrange(cor5,cor6,nrow =2, ncol = 1) 

ggsave(
  "Correlation_na.jpg",
  plot = cor4,
  width = 28,
  height = 10,
  units = c("cm"),
  dpi = 300,
  limitsize = TRUE,
  bg = NULL)

ggsave(
  "Correlation_diff_na.jpg",
  plot = plot_na,
  width = 28,
  height = 20,
  units = c("cm"),
  dpi = 300,
  limitsize = TRUE,
  bg = NULL)
  
  

```


### Random Intercept Regression Models
I only include variables that are overall correlated with the outcome of interest and not completly missing for some participants
```{r eval=FALSE, include=FALSE}
#### Positive affect
formula <- as.formula(paste("pa_mean ~ SOCIAL_min+COMMUNICATION_min+APP_USAGE_min+APPS_OPENED_number+Cluster_HOME_min+UNIQUE_STAYPOINTS_number+TOTAL_MACHASHES_number"))

####
library(caret)

myTimeControl <- trainControl(method = "timeslice",
                              initialWindow = 7,
                              horizon = 1,
                              fixedWindow = TRUE)

model<- train(formula, data=Affect_Passive[Affect_Passive$timescale_beforeESM == "6h" & Affect_Passive$ParticipantNumber == 117134,], trControl = myTimeControl, method="glmnet", na.action = na.omit) 





m####


res_1h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "1h",  ])

res_3h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "3h",  ])
res_6h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "6h",  ])
res_9h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "9h",  ])
res_12h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "12h",  ])
res_24h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "24h",  ])

stargazer(res_1h_pa,res_3h_pa,res_6h_pa,res_9h_pa,res_12h_pa,res_24h_pa, dep.var.labels.include	= T,type = "text")


#### negative affect
formula <- as.formula(paste("na_mean ~ SOCIAL_min+APP_USAGE_min+APPS_OPENED_number+Cluster_HOME_min+TIME_STATIONARY_min + (1 | ParticipantNumber)"))

res_1h_na = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "1h",  ])
res_3h_na = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "3h",  ])
res_6h_na = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "6h",  ])
res_9h_na = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "9h",  ])
res_12h_na = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "12h",  ])
res_24h_na = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "24h",  ])

stargazer(res_1h_na,res_3h_na,res_6h_na,res_9h_na,res_12h_na,res_24h_na, dep.var.labels.include	= T,type = "text")

```

### ADD: Random intercept models: How many interactions someone had


### ADD: Random intercept logistic model for beeing alone




### Example 2 - Rolling Window (I would do a different example)
After aggregating the data (e.g., per hour or per day) researchers often choose a rolling window to analyze the data. For example, Abdullah et al., 2016 aggregated the data on a daily level and then chose a rolling window of seven days to predict how stable the social rhythm of a person is. Other researchers aggregated the data on a hourly level and then chose a rolling window of 24 hours to predict anxiety symptoms (Jacobson & Bhattacharya, 2022, Jacobson & Chung, 2020). Additionally, researchers might want to add more variables to their dataset. For instance, if we aggregated our data on a daily level, we might want to calculate how the behavior varies around certain days and, thus, calculate the variance over a certain time window (Hoogendoorn & Funk, 2018). Even though practical and theoretical considerations might help to choose a specific rolling window, so far, often little justification is given for selecting it. Therefore, the following examples aim to investigate the impact of choosing different rolling windows on the results of the analysis.

In this simple example, we tested whether the correlation between different passive measures and the number of interactions that someone had changes over different rolling windows. Here, we aggregated the passive measures and number of interactions on a daily basis. Afterward we calculated the mean of a passive measure (e.g., percentage of being at Home) over different rolling windows. The following table illustrates how the data looks like (in wide format).

```{r echo=FALSE}
Feature <- c('All_Interactions', "CLUSTER_HOME_pct")
counter = 0

for(i in 1:length(BEHAPP_ID)){
  ParticipantNumbr = BEHAPP_ID[i]
for(k in 1:10){
counter = counter + 1

rolling2 = runner(PerDay[PerDay$ParticipantNumber == ParticipantNumbr,Feature[2]], k = k,function(x) mean(x, na.rm = TRUE), na_pad = TRUE)

if(counter == 1){
data = data.frame(Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr,"Date"],Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr,Feature[1]],Feature2 = rolling2, ParticipantNumbr = ParticipantNumbr, k = k)
}else{
data = rbind(data, data.frame(Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr,"Date"], Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr,Feature[1]],Feature2 = rolling2, ParticipantNumbr = ParticipantNumbr, k = k))
}
}
}


Example <- data[data$ParticipantNumbr == 117113,]
Example <- Example[,colnames(Example) != "ParticipantNumbr"]
Example <- spread(Example,k,Feature2)
colnames(Example) <- c("Date", "Number Interactions",paste(rep("% Home, k =",10),1:10))

DT::renderDataTable(Example[,1:7])
```


#### Descriptive plots
The plots below show the variability of the number of interactions (bar charts) and chosen passive measure (e.g., % of being at Home, line graphs). The pink line displays the raw data of the chosen passive measure. The blue lines show the chosen passive measure calculated over different rolling windows.

```{r echo=FALSE}
shinyApp(
  ui = fluidPage(
    selectInput(
      "PassiveMeasure",
      label = "Passive Measure: ",
      choices = c(
        'SOCIAL_APPS_pct',
        'APP_USAGE_pct',
        'APPS_OPENED_norm',
        'SOCIAL_APPS_min',
        'COMMUNICATION_APPS_pct',
        'COMMUNICATION_APPS_min',
        'APP_USAGE_min',
        'APPS_OPENED_number',
        'CLUSTER_HOME_pct',
        'UNIQUE_STAYPOINTS_norm',
        'TIME_STATIONARY_pct',
        'CLUSTER_HOME_min',
        'UNIQUE_STAYPOINTS_number',
        'TIME_STATIONARY_min',
        'TOTAL_MACHASHES_norm',
        'UNIQUE_MACHASHES_norm',
        'CALL_incoming_pct',
        'CALL_outgoing_pct',
        'CALL_TOTAL_pct',
        'MISSED_CALLS_norm'
      ),
      selected = "CLUSTER_HOME_pct"
    ),
    selectInput(
      "BEHAPP_ID",
      label = "Participant Number: ",
      choices = c(117113,117114,117119,117121,117130,117129,117131,117134,117135,117137),
      selected = c(117113,117114,117119,117121,117130,117129,117131,117134,117135,117137),
      multiple = TRUE
    ),
    plotOutput("Plot")
  ),
  
  server = function(input, output) {
    toListen <- reactive({
    list(input$PassiveMeasure,input$BEHAPP_ID)
  })
    observeEvent(toListen(), {
      Passive = input$PassiveMeasure
      Feature <- c('All_Interactions')
      counter = 0
      
      BEHAPP_ID = input$BEHAPP_ID
      
      for (i in 1:length(BEHAPP_ID)) {
        ParticipantNumbr = BEHAPP_ID[i]
        for (k in 1:10) {
          counter = counter + 1
          
          rolling2 = runner(PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Passive], k = k, function(x)
            mean(x, na.rm = TRUE), na_pad = TRUE)
          
          if (counter == 1) {
            data = data.frame(
              Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, "Date"],
              Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Feature[1]],
              Feature2 = rolling2,
              ParticipantNumbr = ParticipantNumbr,
              k = k
            )
          } else{
            data = rbind(
              data,
              data.frame(
                Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, "Date"],
                Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Feature[1]],
                Feature2 = rolling2,
                ParticipantNumbr = ParticipantNumbr,
                k = k
              )
            )
          }
        }
      }
      data[data$k != 1, ]$Feature1 = NA
      max = max(data$Feature1, na.rm = TRUE)
      maxy = max(data$Feature2,na.rm = TRUE)
      
      if(max > maxy){
        scaleplot = 0.1*maxy
      }else{
        scaleplot = maxy/max
      }

      output$Plot = renderPlot({
          ggplot(data, aes(x = Date)) +
            geom_bar(stat = 'identity', aes(y = Feature1 * scaleplot)) +
            geom_line(aes(y = Feature2, color = as.factor(k))) +
            scale_color_manual(
              values = c(
                "#f95d6a",
                "#90F1B3",
                "#255e7e",
                "#3CD8DA",
                "#5383a1",
                "#3CD8DA",
                "#7faac6",
                "#218CB3",
                "#abd2ec",
                "#c1e7ff"
              )
            ) +
            ylab(Passive) +
            theme_minimal() +
            scale_y_continuous(
              name = paste(Passive),
              limits = c(0, maxy),
              sec.axis = sec_axis( ~ . / scaleplot, name = 'Number of Interactions')
            ) +
            facet_wrap( ~ ParticipantNumbr, ncol = 2, scales = 'free')
        
      },  height = 500, width = 800)
      
    })
  },
  options = list(height = 730, width = 820)
)
```

#### Correlation
Next, I calculated the correlation between the number of interactions and a chosen passive measure. The plot below visualize the results. The right and the left plot are based on the same data and are just different visualization options. The first row of the left plot and the pink line of the right plot shows the overall correlation between the number of interactions and chosen passive measure (calculated over all participants). The other rows/blue lines show the correlation per participant. A star indicates that the result was significant.

Interestingly, the overall correlation (i.e., calculated over all participants, first row (left), pink line (right)) seems to be relatively stable over different rolling windows, whereas the individual correlations seems fo be more fluctuating over different rolling windows (this is the same pattern as obsereved when we looked at the correlations between different aggregated passive measures). 

This indicates that it is important to pay attention to which rolling window was chosen while interpreting individualized results/models. For example, if we want to validate passive measures as indicator for social behavior, we might want to do this for different time windows. This also might be important when we are interpreting the feature importance of (individualized) predictive models. 


```{r echo=FALSE}
shinyApp(
  ui = fluidPage(
    selectInput(
      "PassiveMeasure",
      label = "Passive Measure: ",
      choices = c(
        'SOCIAL_APPS_pct',
        'APP_USAGE_pct',
        'APPS_OPENED_norm',
        'SOCIAL_APPS_min',
        'COMMUNICATION_APPS_pct',
        'COMMUNICATION_APPS_min',
        'APP_USAGE_min',
        'APPS_OPENED_number',
        'CLUSTER_HOME_pct',
        'UNIQUE_STAYPOINTS_norm',
        'TIME_STATIONARY_pct',
        'CLUSTER_HOME_min',
        'UNIQUE_STAYPOINTS_number',
        'TIME_STATIONARY_min',
        'TOTAL_MACHASHES_norm',
        'UNIQUE_MACHASHES_norm',
        'CALL_incoming_pct',
        'CALL_outgoing_pct',
        'CALL_TOTAL_pct',
        'MISSED_CALLS_norm'
      ),
      selected = "CLUSTER_HOME_pct"
    ),
    plotOutput("Plot")
  ),
  
  server = function(input, output) {
    observeEvent(input$PassiveMeasure, {
      Passive = input$PassiveMeasure
      Feature <- c('All_Interactions')
      counter = 0
      
      BEHAPP_ID = c(117113,117114,117119,117121,117130,117129,117131,117134,117135,117137)
      
      for (i in 1:length(BEHAPP_ID)) {
        ParticipantNumbr = BEHAPP_ID[i]
        for (k in 1:10) {
          counter = counter + 1
          
          rolling2 = runner(PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Passive], k = k, function(x)
            mean(x, na.rm = TRUE), na_pad = TRUE)
          
          if (counter == 1) {
            data = data.frame(
              Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, "Date"],
              Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Feature[1]],
              Feature2 = rolling2,
              ParticipantNumbr = ParticipantNumbr,
              k = k
            )
          } else{
            data = rbind(
              data,
              data.frame(
                Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, "Date"],
                Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Feature[1]],
                Feature2 = rolling2,
                ParticipantNumbr = ParticipantNumbr,
                k = k
              )
            )
          }
        }
      }
      Correlation = data %>%
        group_by(ParticipantNumbr, k) %>%
        summarize(
          "Size" = "thin",
          "Correlation" = ifelse(
            sum(Feature2, na.rm = TRUE) != 0,
            as.numeric(cor.test(Feature1, Feature2)$estimate),
            NA
          ),
          "p.value" = ifelse(sum(Feature2, na.rm = TRUE) != 0, round(cor.test(Feature1, Feature2)$p.value, 2), NA)
        )
      
      Correlation$ParticipantNumbr <-
        as.character(Correlation$ParticipantNumbr)
      
      OverallCorrelation = data %>%
        group_by(k) %>%
        summarize(
          "Size" = "thick",
          "ParticipantNumbr" = "Overall",
          Correlation = as.numeric(cor.test(Feature1, Feature2)$estimate),
          "p.value" = round(cor.test(Feature1, Feature2)$p.value, 2)
        )
      
      Correlation = rbind(Correlation, OverallCorrelation)
      
      
      
      Correlation$sign = "non-sign"
      Correlation[!is.na(Correlation$p.value) &
                    Correlation$p.value <= 0.05, ]$sign = "sign"
      
      Correlation$star = ""
      Correlation[!is.na(Correlation$p.value) &
                    Correlation$p.value <= 0.05, ]$star = "*"
      
      
      cor1 =  ggplot(Correlation,
                     aes(
                       y = as.factor(ParticipantNumbr),
                       x = as.factor(k),
                       fill = Correlation
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6") +
        geom_text(aes(label = star), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Correlation between", Feature[1], "&", Passive)) +
        theme_minimal()
      
      
      cor2 = ggplot(Correlation, aes(x = k)) +
        geom_line(aes(
          y = Correlation,
          color = as.factor(ParticipantNumbr),
          size = Size
        )) +
        geom_point(aes(
          y = Correlation,
          color = as.factor(ParticipantNumbr),
          shape = sign
        )) +
        scale_size_manual(values = c(1, 0.5)) +
        scale_shape_manual(values = c("sign" = 8, "non-sign" = 16)) +
        xlab("Rolling Window") +
        theme_minimal() +
        theme(panel.grid.minor.y = element_blank()) +
        scale_x_discrete(limits = c("k = 1", paste(rep("k =", 9), 2:10))) +
        ggtitle(paste("Correlation between", Feature[1], "&", Passive)) +
        guides(shape = guide_legend(""),
               size = FALSE,
               color = guide_legend("")) +
            scale_color_manual(
              values = c("#08324f","#90F1B3", "#255e7e", "#3CD8DA", "#5383a1", "#3CD8DA", "#7faac6", "#218CB3", "#abd2ec", "#c1e7ff", "#f95d6a"))
      
      
      output$Plot = renderPlot({ggarrange(cor1,cor2)
      },  height = 400, width = 800)
      
    })
  },
  options = list(height = 500, width = 820)
)
```


### Prediciton or other analysis with rolling window?

```{r eval=FALSE, include=FALSE}
Passive = c("COMMUNICATION_APPS_pct","APP_USAGE_pct","APPS_OPENED_norm","CLUSTER_HOME_pct","UNIQUE_STAYPOINTS_norm","UNIQUE_MACHASHES_norm")
counter = 0
for(j in 1:length(Passive)){
      for (i in 1:length(BEHAPP_ID)) {
        ParticipantNumbr = BEHAPP_ID[i]
        for (k in 1:10) {
          counter = counter + 1
          
          rolling2 = runner(PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Passive[j]], k = k, function(x)
            mean(x, na.rm = TRUE), na_pad = TRUE)
          
          if (counter == 1) {
            data = data.frame(
              Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, "Date"],
              Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Feature[1]],
              Feature2 = rolling2,
              ParticipantNumbr = ParticipantNumbr,
              k = k,
              Feature = Passive[j]
            )
          } else{
            data = rbind(
              data,
              data.frame(
                Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, "Date"],
                Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Feature[1]],
                Feature2 = rolling2,
                ParticipantNumbr = ParticipantNumbr,
                k = k,
                Feature = Passive[j]
              )
            )
          }
        }
      }
}

```

```{r eval=FALSE, include=FALSE}
### Regression
library(lme4)
resultMulti <- list()

for(k in 1:10){
dataReg <- data[data$k == k,] %>% spread(Feature, Feature2)
colnames(dataReg)[colnames(dataReg) == 'Feature1'] <- 'All_Interactions'
colnames(dataReg)[colnames(dataReg) == 'ParticipantNumbr'] <- 'ParticipantNumber'

formula <- as.formula(paste("All_Interactions ~ COMMUNICATION_APPS_pct +APP_USAGE_pct + +APPS_OPENED_norm+CLUSTER_HOME_pct+UNIQUE_STAYPOINTS_norm+UNIQUE_MACHASHES_norm"))

formulaMulti <- as.formula(paste("All_Interactions ~ COMMUNICATION_APPS_pct +APP_USAGE_pct + +APPS_OPENED_norm+CLUSTER_HOME_pct+UNIQUE_STAYPOINTS_norm+UNIQUE_MACHASHES_norm + (1 | ParticipantNumber)"))

resultMulti[[k]] <- lmer(formulaMulti, data=dataReg)
}


dwplot(resultMulti, vline = geom_vline(
               xintercept = 0,
               colour = "grey60",
               linetype = 2
           )) +
  theme_minimal() +
  ggtitle("")


```



```{r eval=FALSE, include=FALSE}

###
TestData = PerDay[PerDay$ParticipantNumber == 117134,]
TestData = TestData[1:30,]


myTimeControl <- trainControl(method = "timeslice",
                              initialWindow = 7,
                              horizon = 1,
                              fixedWindow = TRUE)

model<- train(formula, data=TestData, trControl = myTimeControl, method="pls", na.action = na.omit) 



# https://topepo.github.io/caret/data-splitting.html#data-splitting-for-time-series

timeSlices <- createTimeSlices(1:nrow(TestData), 
                   initialWindow = 7, horizon = 1, fixedWindow = TRUE)


trainSlices <- timeSlices[[1]]
testSlices <- timeSlices[[2]]


#The results in folds can be used as inputs into the index argument of the trainControl function



for(i in 1:length(trainSlices)){
model<- train(formula, data=TestData[trainSlices[[1]],], method="pls", na.action = na.omit) 

pred <- predict(model,TestData[testSlices[[1]],])

true <- TestData$All_Interactions[testSlices[[1]]]
}

#####
folds <- groupKFold(PerDay$ParticipantNumber, k = 7) 
ctrl <- trainControl(index = folds, method = 'cv')
z
train <- PerDay[folds[[1]],]
test <- PerDay[-folds[[1]],]

model <- train(formula, data=train, method="lm", na.action = na.omit) 


```

### Old code chunks (deleted from TimeScalePaper)

Old code used for shiny app etc but now deleted



```{r echo=FALSE}
shinyApp(
  ui = fluidPage(
    selectInput(
      "PassiveMeasure",
      label = "Passive Measure: ",
      choices = c(
        'SOCIAL_min',
        'COMMUNICATION_min',
        'APP_USAGE_min',
        'APPS_OPENED_number',
        'Cluster_HOME_min',
        'UNIQUE_STAYPOINTS_number',
        'TIME_STATIONARY_min',
        'TOTAL_MACHASHES_number',
        'UNIQUE_MACHASHES_number',
        "BLUETOOTH_TOTAL_MACHASHES_number"
      ),
      selected = "SOCIAL_min_"
    ),selectInput(
      "Affect",
      label = "Affect: ",
      choices = c(
        'pa_mean',
        'na_mean'
      ),
      selected = "pa_mean"
    ),
    sliderInput(
      "sample",
      label = "Random sample:",
      min = 1,
      max = 500,
      value = 1
    ),
    plotOutput("Plot")
  ),
  
  server = function(input, output) {
    toListen <- reactive({
    list(input$PassiveMeasure,input$Affect, input$sample)
  })
    observeEvent(toListen(),{
      Passive = input$PassiveMeasure
      Feature <- input$Affect
      sample <- input$sample
     
      cor1 =  ggplot(CorrelationSampleTrue[CorrelationSampleTrue$Feature == Passive, ],
                     aes(
                       y = as.factor(ParticipantNumber),
                       x = as.factor(timescale_beforeESM),
                       fill = Correlation
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = star_combined), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("True data: Correlation between", Feature, "&", Passive)) +
        theme_minimal()
      
      
      cor2 = ggplot(CorrelationSampleTrue[CorrelationSampleTrue$Feature == Passive, ], aes(x = timescale_beforeESM_num)) +
        geom_line(aes(
          y = Correlation,
          color = ParticipantNumber,
          size = Size
        )) +
        geom_point(aes(
          y = Correlation,
          color = as.factor(ParticipantNumber),
          shape = sign
        )) +
        scale_size_manual(values = c(1, 0.5)) +
        scale_shape_manual(values = c("sign" = 8, "non-sign" = 16)) +
        xlab("time scale for aggregation") +
        theme_minimal() +
        theme(panel.grid.minor.y = element_blank()) +
        ggtitle(paste("")) +
        guides(shape = guide_legend(""),
               size = FALSE,
               color = guide_legend("")) +
            scale_color_manual(
              values = c("#08324f","#90F1B3", "#255e7e", "#3CD8DA", "#5383a1", "#3CD8DA", "#7faac6", "#218CB3", "#abd2ec", "#c1e7ff", "#f95d6a")) +
        scale_x_discrete(limits = c(3,6,9,12),labels = c("3h", "6h","9h", "12h")) +
        ylim(c(-0.5,0.5))
      
      ### random
      
           cor3 =  ggplot(CorrelationSampleCombined[CorrelationSampleCombined$Feature == Passive & CorrelationSampleCombined$sample == sample, ],
                     aes(
                       y = as.factor(ParticipantNumber),
                       x = as.factor(timescale_beforeESM),
                       fill = Correlation
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits = c(-0.5,0.5)) +
        geom_text(aes(label = star), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Random sample: Correlation between", Feature, "&", Passive)) +
        theme_minimal()
      
      
      cor4 = ggplot(CorrelationSampleCombined[CorrelationSampleCombined$Feature == Passive & CorrelationSampleCombined$sample == sample, ], aes(x = timescale_beforeESM_num)) +
        geom_line(aes(
          y = Correlation,
          color = ParticipantNumber,
          size = Size
        )) +
        geom_point(aes(
          y = Correlation,
          color = as.factor(ParticipantNumber),
          shape = sign
        )) +
        scale_size_manual(values = c(1, 0.5)) +
        scale_shape_manual(values = c("sign" = 8, "non-sign" = 16)) +
        xlab("time scale for aggregation") +
        theme_minimal() +
        theme(panel.grid.minor.y = element_blank()) +
        ggtitle(paste("")) +
        guides(shape = guide_legend(""),
               size = FALSE,
               color = guide_legend("")) +
            scale_color_manual(
              values = c("#08324f","#90F1B3", "#255e7e", "#3CD8DA", "#5383a1", "#3CD8DA", "#7faac6", "#218CB3", "#abd2ec", "#c1e7ff", "#f95d6a")) +
        scale_x_discrete(limits = c(3,6,9,12),labels = c("3h", "6h","9h", "12h")) +
        ylim(c(-0.5,0.5))
      
cor5 = ggplot(CorrelationSampleCombinedSign[CorrelationSampleCombinedSign$Feature == Passive, ],
                     aes(
                       y = as.factor(ParticipantNumber),
                       x = as.factor(timescale_beforeESM),
                       fill = count_sign
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6") +
        geom_text(aes(label = paste(count_sign*100, "%")), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Percentage of being significant in random sample")) +
        theme_minimal()
      
      
      output$Plot = renderPlot({ggarrange(cor1,cor2,cor3,cor4,cor5,nrow =3, ncol = 2)
      },  height = 800, width = 800)
      
    })
  },
  options = list(height = 1200, width = 820)
)
```

```{r echo=FALSE}
#### OLD VERSION ####
### DELETE ###
shinyApp(
  ui = fluidPage(
    selectInput(
      "PassiveMeasure",
      label = "Passive Measure: ",
      choices = c(
        'SOCIAL_min',
        'COMMUNICATION_min',
        'APP_USAGE_min',
        'APPS_OPENED_number',
        'Cluster_HOME_min',
        'UNIQUE_STAYPOINTS_number',
        'TIME_STATIONARY_min',
        'TOTAL_MACHASHES_number',
        'UNIQUE_MACHASHES_number',
        "BLUETOOTH_TOTAL_MACHASHES_number",
        'CALL_TOTAL_min',
        "Cluster_0_min",
        "Cluster_1_min",
        "Cluster_2_min",
        "Cluster_3_min",
        "Cluster_4_min",
        "Cluster_5_min"
      ),
      selected = "Cluster_HOME_min"
    ),selectInput(
      "Affect",
      label = "Affect: ",
      choices = c(
        'pa_mean',
        'na_mean'
      ),
      selected = "pa_mean"
    ),
    plotOutput("Plot")
  ),
  
  server = function(input, output) {
    toListen <- reactive({
    list(input$PassiveMeasure,input$Affect)
  })
    observeEvent(toListen(),{
      Passive = input$PassiveMeasure
      Feature <- input$Affect
      counter = 0
      
      BEHAPP_ID = c(117113,117114,117119,117121,117130,117129,117131,117134,117135,117137)
      
      #create a new columns to check sum
      Affect_Passive[,"Passivecopy"] <- Affect_Passive[,colnames(Affect_Passive) == Passive]
      
      Correlation = Affect_Passive %>%
        group_by(ParticipantNumber, timescale_beforeESM) %>%
        summarize(
          "Size" = "thin",
          "Correlation" = ifelse(
            sum(Passivecopy, na.rm = TRUE) != 0,
            as.numeric(cor.test(as.formula(paste("~",Feature, "+",Passive)))$estimate),
            NA
          ),
          "p.value" = ifelse(sum(Passivecopy, na.rm = TRUE) != 0, round(cor.test(as.formula(paste("~",Feature, "+",Passive)))$p.value, 2), NA)
        )
      
      Correlation$ParticipantNumber <-
        as.character(Correlation$ParticipantNumber)
      
      OverallCorrelation = Affect_Passive %>%
        group_by(timescale_beforeESM) %>%
        summarize(
          "Size" = "thick",
          "ParticipantNumber" = "Overall",
          Correlation = as.numeric(cor.test(as.formula(paste("~",Feature, "+",Passive)))$estimate),
          "p.value" = round(cor.test(as.formula(paste("~",Feature, "+",Passive)))$p.value, 2)
        )
      
      Correlation = rbind(Correlation, OverallCorrelation)
      
      
      
      Correlation$sign = "non-sign"
      Correlation[!is.na(Correlation$p.value) &
                    Correlation$p.value <= 0.05, ]$sign = "sign"
      
      Correlation$star = ""
      Correlation[!is.na(Correlation$p.value) &
                    Correlation$p.value <= 0.05, ]$star = "*"
      
     Correlation$timescale_beforeESM_num <- recode(Correlation$timescale_beforeESM, "1h" = 1, "3h" = 3,"6h" = 6,"9h" = 9,"12h" = 12, "24h" = 24 )
     
     Correlation$timescale_beforeESM <- ordered(Correlation$timescale_beforeESM,levels = c("1h","3h","6h","9h","12h","24h"))
      
      cor1 =  ggplot(Correlation,
                     aes(
                       y = as.factor(ParticipantNumber),
                       x = as.factor(timescale_beforeESM),
                       fill = Correlation
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6") +
        geom_text(aes(label = star), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Correlation between", Feature, "&", Passive)) +
        theme_minimal()
      
      
      cor2 = ggplot(Correlation, aes(x = timescale_beforeESM_num)) +
        geom_line(aes(
          y = Correlation,
          color = ParticipantNumber,
          size = Size
        )) +
        geom_point(aes(
          y = Correlation,
          color = as.factor(ParticipantNumber),
          shape = sign
        )) +
        scale_size_manual(values = c(1, 0.5)) +
        scale_shape_manual(values = c("sign" = 8, "non-sign" = 16)) +
        xlab("time scale for aggregation") +
        theme_minimal() +
        theme(panel.grid.minor.y = element_blank()) +
        ggtitle(paste("Correlation between", Feature, "&", Passive)) +
        guides(shape = guide_legend(""),
               size = FALSE,
               color = guide_legend("")) +
            scale_color_manual(
              values = c("#08324f","#90F1B3", "#255e7e", "#3CD8DA", "#5383a1", "#3CD8DA", "#7faac6", "#218CB3", "#abd2ec", "#c1e7ff", "#f95d6a")) +
        scale_x_discrete(limits = c(1,3,6,9,12,24),labels = c("1h","3h","6h","9h","12h","24"))
      
      
      output$Plot = renderPlot({ggarrange(cor1,cor2)
      },  height = 400, width = 800)
      
    })
  },
  options = list(height = 600, width = 820)
)
```


```{r echo=FALSE}

#### PLOT FOR PAPER OLD
      cor1 = CorrelationSampleTrue[CorrelationSampleTrue$ParticipantNumber %in% c(117119,117130),] %>% filter(., Feature == "Cluster_HOME_min" |  Feature == "CALL_TOTAL_min") %>% 
                ggplot(.,
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = Correlation
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = star), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Correlations between mean positive affect and passive measures")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
  theme(axis.text.y = element_text(size= 12))  
    
 cor2 =  CorrelationSampleTrue_allNA[CorrelationSampleTrue_allNA$ParticipantNumber  %in% c(117119,117130),] %>% filter(., Feature == "Cluster_HOME_min" |  Feature == "CALL_TOTAL_min") %>% 
                ggplot(.,
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = diff
                     )) +
        geom_tile() +
        scale_fill_gradient(low = "white", high = "#2C7BB6",  limits =  c(0,0.5)) +
        geom_text(aes(label = diff_sign), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Absolute difference between omitting values sensor specific and non-sensor specific")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
   labs(fill="Difference") +
  theme(axis.text.y = element_text(size= 12))  
 
 
 

      cor3 =  CorrelationSampleTrue_noNA[CorrelationSampleTrue_noNA$ParticipantNumber  %in% c(117119,117130),] %>% filter(., Feature == "Cluster_HOME_min" |  Feature == "CALL_TOTAL_min") %>%  
                ggplot(.,
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = diff
                     )) +
        geom_tile() +
        scale_fill_gradient(low = "white", high = "#2C7BB6",  limits =  c(0,1))  +
        geom_text(aes(label = diff_sign), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Absolute difference between omitting values sensor specific and ignoring missing values")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
        labs(fill="Difference") +
  theme(axis.text.y = element_text(size= 12))  
      
plot <- ggarrange(cor2,cor3,nrow =2, ncol = 1)

ggsave(
  "Correlation_less.jpg",
  plot = cor1,
  width = 28,
  height = 10,
  units = c("cm"),
  dpi = 300,
  limitsize = TRUE,
  bg = NULL)

ggsave(
  "Correlation_less_diff.jpg",
  plot = plot,
  width = 28,
  height = 20,
  units = c("cm"),
  dpi = 300,
  limitsize = TRUE,
  bg = NULL)


 cor4 =  ggplot(CorrelationSampleTrue_na[CorrelationSampleTrue_na$ParticipantNumber %in% c(117119,117130,117134,"Overall"),],
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = Correlation
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = star), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Correlations between mean negative affect and passive measures")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
  theme(axis.text.y = element_text(size= 12))  
 
 
 cor5 =  ggplot(CorrelationSampleTrue_na_allNA[CorrelationSampleTrue_na_allNA$ParticipantNumber %in% c(117119,117130,117134,"Overall"),],
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = diff
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = diff_sign), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Difference between omitting values sensor specific and non-sensor specific")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
   labs(fill="Difference") +
  theme(axis.text.y = element_text(size= 12))  
 
 
 

      cor6 =  ggplot(CorrelationSampleTrue_na_noNA[CorrelationSampleTrue_na_noNA$ParticipantNumber %in% c(117119,117130,117134,"Overall"),],
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = diff
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = diff_sign), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Difference between omitting values sensor specific and ignoring missing values")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
        labs(fill="Difference") +
  theme(axis.text.y = element_text(size= 12))  
      
plot_na <- ggarrange(cor5,cor6,nrow =2, ncol = 1) 

ggsave(
  "Correlation_na.jpg",
  plot = cor4,
  width = 28,
  height = 10,
  units = c("cm"),
  dpi = 300,
  limitsize = TRUE,
  bg = NULL)

ggsave(
  "Correlation_diff_na.jpg",
  plot = plot_na,
  width = 28,
  height = 20,
  units = c("cm"),
  dpi = 300,
  limitsize = TRUE,
  bg = NULL)
  
  

```


### OLD: Rolling Window (I would do a different example)
After aggregating the data (e.g., per hour or per day) researchers often choose a rolling window to analyze the data. For example, Abdullah et al., 2016 aggregated the data on a daily level and then chose a rolling window of seven days to predict how stable the social rhythm of a person is. Other researchers aggregated the data on a hourly level and then chose a rolling window of 24 hours to predict anxiety symptoms (Jacobson & Bhattacharya, 2022, Jacobson & Chung, 2020). Additionally, researchers might want to add more variables to their dataset. For instance, if we aggregated our data on a daily level, we might want to calculate how the behavior varies around certain days and, thus, calculate the variance over a certain time window (Hoogendoorn & Funk, 2018). Even though practical and theoretical considerations might help to choose a specific rolling window, so far, often little justification is given for selecting it. Therefore, the following examples aim to investigate the impact of choosing different rolling windows on the results of the analysis.

In this simple example, we tested whether the correlation between different passive measures and the number of interactions that someone had changes over different rolling windows. Here, we aggregated the passive measures and number of interactions on a daily basis. Afterward we calculated the mean of a passive measure (e.g., percentage of being at Home) over different rolling windows. The following table illustrates how the data looks like (in wide format).

```{r echo=FALSE}

var_1h_wide <- calculate_runnner_dataset(Affect_Passive, TIME = "1h")
var_1h <- calculateCorr_pa_var(var_1h_wide)

var_3h_wide <- calculate_runnner_dataset(Affect_Passive, TIME = "3h")
var_3h <- calculateCorr_pa_var(var_3h_wide)

var_6h_wide <- calculate_runnner_dataset(Affect_Passive,  TIME = "6h")
var_6h <- calculateCorr_pa_var(var_6h_wide)

```

```{r echo=FALSE}
library(grid)

var_3h_wide$timescale_beforeESM <- as.factor(var_3h_wide$timescale_beforeESM)

plot1 <- ggplot(var_3h_wide[var_3h_wide$ParticipantNumber %in% c(117134),]) +
  geom_line(aes(y = Cluster_HOME_min, x = as.POSIXct(Date), color = timescale_beforeESM)) +
  theme_minimal() +
  xlab("") + 
  ylab("") +
  labs(color='') 


plot2 <- ggplot(var_3h_wide[var_3h_wide$ParticipantNumber %in% c(117134),], aes(x=timescale_beforeESM, y=Cluster_HOME_min, fill = timescale_beforeESM)) + 
  geom_violin(trim=TRUE, width = 1) +
  theme_minimal() +
  xlab("") + 
  ylab("") +
  labs(fill='') 

plot <- ggarrange(plot1, plot2, ncol = 1, common.legend = TRUE, legend = "right") 

annotate_figure(plot, left = textGrob("Cluster_HOME_min", rot = 90, vjust = 1, gp = gpar(cex = 1)))
```


```{r echo=FALSE}


  corvar = var_3h[var_3h$ParticipantNumber %in% c(117119,117130,117134,"Overall"),] %>% filter(., Feature == "TIME_STATIONARY_min" | Feature == "Cluster_HOME_min" | Feature == "APP_USAGE_min" | Feature == "CALL_TOTAL_min" | Feature == "CALL_incoming_number" )  %>%
                ggplot(.,
                     aes(
                       y = as.factor(Feature),
                       x = as.factor(timescale_beforeESM),
                       fill = Correlation
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6", limits =  c(-0.5,0.5)) +
        geom_text(aes(label = star), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Correlations between the variance of mean positive affect and passive measures")) +
        theme_minimal() +
        facet_grid( ~ ParticipantNumber, scales = 'free') +
  theme(axis.text.y = element_text(size= 12))  


```


#### Descriptive plots
The plots below show the variability of the number of interactions (bar charts) and chosen passive measure (e.g., % of being at Home, line graphs). The pink line displays the raw data of the chosen passive measure. The blue lines show the chosen passive measure calculated over different rolling windows.

```{r echo=FALSE}

          ggplot(var_3h_wide[var_3h_wide$ParticipantNumber %in% c(117134),], aes(x = as.POSIXct(Date), y = Cluster_HOME_min)) +
            geom_line(aes(color = as.factor(timescale_beforeESM))) +
            theme_minimal()
```

#### Correlation
Next, I calculated the correlation between the number of interactions and a chosen passive measure. The plot below visualize the results. The right and the left plot are based on the same data and are just different visualization options. The first row of the left plot and the pink line of the right plot shows the overall correlation between the number of interactions and chosen passive measure (calculated over all participants). The other rows/blue lines show the correlation per participant. A star indicates that the result was significant.

Interestingly, the overall correlation (i.e., calculated over all participants, first row (left), pink line (right)) seems to be relatively stable over different rolling windows, whereas the individual correlations seems fo be more fluctuating over different rolling windows (this is the same pattern as obsereved when we looked at the correlations between different aggregated passive measures). 

This indicates that it is important to pay attention to which rolling window was chosen while interpreting individualized results/models. For example, if we want to validate passive measures as indicator for social behavior, we might want to do this for different time windows. This also might be important when we are interpreting the feature importance of (individualized) predictive models. 


```{r echo=FALSE}
shinyApp(
  ui = fluidPage(
    selectInput(
      "PassiveMeasure",
      label = "Passive Measure: ",
      choices = c(
        'SOCIAL_APPS_pct',
        'APP_USAGE_pct',
        'APPS_OPENED_norm',
        'SOCIAL_APPS_min',
        'COMMUNICATION_APPS_pct',
        'COMMUNICATION_APPS_min',
        'APP_USAGE_min',
        'APPS_OPENED_number',
        'CLUSTER_HOME_pct',
        'UNIQUE_STAYPOINTS_norm',
        'TIME_STATIONARY_pct',
        'CLUSTER_HOME_min',
        'UNIQUE_STAYPOINTS_number',
        'TIME_STATIONARY_min',
        'TOTAL_MACHASHES_norm',
        'UNIQUE_MACHASHES_norm',
        'CALL_incoming_pct',
        'CALL_outgoing_pct',
        'CALL_TOTAL_pct',
        'MISSED_CALLS_norm'
      ),
      selected = "CLUSTER_HOME_pct"
    ),
    plotOutput("Plot")
  ),
  
  server = function(input, output) {
    observeEvent(input$PassiveMeasure, {
      Passive = input$PassiveMeasure
      Feature <- c('All_Interactions')
      counter = 0
      
      BEHAPP_ID = c(117113,117114,117119,117121,117130,117129,117131,117134,117135,117137)
      
      for (i in 1:length(BEHAPP_ID)) {
        ParticipantNumbr = BEHAPP_ID[i]
        for (k in 1:10) {
          counter = counter + 1
          
          rolling2 = runner(PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Passive], k = k, function(x)
            mean(x, na.rm = TRUE), na_pad = TRUE)
          
          if (counter == 1) {
            data = data.frame(
              Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, "Date"],
              Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Feature[1]],
              Feature2 = rolling2,
              ParticipantNumbr = ParticipantNumbr,
              k = k
            )
          } else{
            data = rbind(
              data,
              data.frame(
                Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, "Date"],
                Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Feature[1]],
                Feature2 = rolling2,
                ParticipantNumbr = ParticipantNumbr,
                k = k
              )
            )
          }
        }
      }
      Correlation = data %>%
        group_by(ParticipantNumbr, k) %>%
        summarize(
          "Size" = "thin",
          "Correlation" = ifelse(
            sum(Feature2, na.rm = TRUE) != 0,
            as.numeric(cor.test(Feature1, Feature2)$estimate),
            NA
          ),
          "p.value" = ifelse(sum(Feature2, na.rm = TRUE) != 0, round(cor.test(Feature1, Feature2)$p.value, 2), NA)
        )
      
      Correlation$ParticipantNumbr <-
        as.character(Correlation$ParticipantNumbr)
      
      OverallCorrelation = data %>%
        group_by(k) %>%
        summarize(
          "Size" = "thick",
          "ParticipantNumbr" = "Overall",
          Correlation = as.numeric(cor.test(Feature1, Feature2)$estimate),
          "p.value" = round(cor.test(Feature1, Feature2)$p.value, 2)
        )
      
      Correlation = rbind(Correlation, OverallCorrelation)
      
      
      
      Correlation$sign = "non-sign"
      Correlation[!is.na(Correlation$p.value) &
                    Correlation$p.value <= 0.05, ]$sign = "sign"
      
      Correlation$star = ""
      Correlation[!is.na(Correlation$p.value) &
                    Correlation$p.value <= 0.05, ]$star = "*"
      
      
      cor1 =  ggplot(Correlation,
                     aes(
                       y = as.factor(ParticipantNumbr),
                       x = as.factor(k),
                       fill = Correlation
                     )) +
        geom_tile() +
        scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6") +
        geom_text(aes(label = star), color = "black", size = 4) +
        ylab("") +
        xlab("") +
        ggtitle(paste("Correlation between", Feature[1], "&", Passive)) +
        theme_minimal()
      
      
      cor2 = ggplot(Correlation, aes(x = k)) +
        geom_line(aes(
          y = Correlation,
          color = as.factor(ParticipantNumbr),
          size = Size
        )) +
        geom_point(aes(
          y = Correlation,
          color = as.factor(ParticipantNumbr),
          shape = sign
        )) +
        scale_size_manual(values = c(1, 0.5)) +
        scale_shape_manual(values = c("sign" = 8, "non-sign" = 16)) +
        xlab("Rolling Window") +
        theme_minimal() +
        theme(panel.grid.minor.y = element_blank()) +
        scale_x_discrete(limits = c("k = 1", paste(rep("k =", 9), 2:10))) +
        ggtitle(paste("Correlation between", Feature[1], "&", Passive)) +
        guides(shape = guide_legend(""),
               size = FALSE,
               color = guide_legend("")) +
            scale_color_manual(
              values = c("#08324f","#90F1B3", "#255e7e", "#3CD8DA", "#5383a1", "#3CD8DA", "#7faac6", "#218CB3", "#abd2ec", "#c1e7ff", "#f95d6a"))
      
      
      output$Plot = renderPlot({ggarrange(cor1,cor2)
      },  height = 400, width = 800)
      
    })
  },
  options = list(height = 500, width = 820)
)
```


### Prediciton or other analysis with rolling window?

```{r eval=FALSE, include=FALSE}
Passive = c("COMMUNICATION_APPS_pct","APP_USAGE_pct","APPS_OPENED_norm","CLUSTER_HOME_pct","UNIQUE_STAYPOINTS_norm","UNIQUE_MACHASHES_norm")
counter = 0
for(j in 1:length(Passive)){
      for (i in 1:length(BEHAPP_ID)) {
        ParticipantNumbr = BEHAPP_ID[i]
        for (k in 1:10) {
          counter = counter + 1
          
          rolling2 = runner(PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Passive[j]], k = k, function(x)
            mean(x, na.rm = TRUE), na_pad = TRUE)
          
          if (counter == 1) {
            data = data.frame(
              Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, "Date"],
              Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Feature[1]],
              Feature2 = rolling2,
              ParticipantNumbr = ParticipantNumbr,
              k = k,
              Feature = Passive[j]
            )
          } else{
            data = rbind(
              data,
              data.frame(
                Date = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, "Date"],
                Feature1 = PerDay[PerDay$ParticipantNumber == ParticipantNumbr, Feature[1]],
                Feature2 = rolling2,
                ParticipantNumbr = ParticipantNumbr,
                k = k,
                Feature = Passive[j]
              )
            )
          }
        }
      }
}

```

```{r eval=FALSE, include=FALSE}
### Regression
library(lme4)
resultMulti <- list()

for(k in 1:10){
dataReg <- data[data$k == k,] %>% spread(Feature, Feature2)
colnames(dataReg)[colnames(dataReg) == 'Feature1'] <- 'All_Interactions'
colnames(dataReg)[colnames(dataReg) == 'ParticipantNumbr'] <- 'ParticipantNumber'

formula <- as.formula(paste("All_Interactions ~ COMMUNICATION_APPS_pct +APP_USAGE_pct + +APPS_OPENED_norm+CLUSTER_HOME_pct+UNIQUE_STAYPOINTS_norm+UNIQUE_MACHASHES_norm"))

formulaMulti <- as.formula(paste("All_Interactions ~ COMMUNICATION_APPS_pct +APP_USAGE_pct + +APPS_OPENED_norm+CLUSTER_HOME_pct+UNIQUE_STAYPOINTS_norm+UNIQUE_MACHASHES_norm + (1 | ParticipantNumber)"))

resultMulti[[k]] <- lmer(formulaMulti, data=dataReg)
}


dwplot(resultMulti, vline = geom_vline(
               xintercept = 0,
               colour = "grey60",
               linetype = 2
           )) +
  theme_minimal() +
  ggtitle("")


```



```{r eval=FALSE, include=FALSE}

###
TestData = PerDay[PerDay$ParticipantNumber == 117134,]
TestData = TestData[1:30,]


myTimeControl <- trainControl(method = "timeslice",
                              initialWindow = 7,
                              horizon = 1,
                              fixedWindow = TRUE)

model<- train(formula, data=TestData, trControl = myTimeControl, method="pls", na.action = na.omit) 



# https://topepo.github.io/caret/data-splitting.html#data-splitting-for-time-series

timeSlices <- createTimeSlices(1:nrow(TestData), 
                   initialWindow = 7, horizon = 1, fixedWindow = TRUE)


trainSlices <- timeSlices[[1]]
testSlices <- timeSlices[[2]]


#The results in folds can be used as inputs into the index argument of the trainControl function



for(i in 1:length(trainSlices)){
model<- train(formula, data=TestData[trainSlices[[1]],], method="pls", na.action = na.omit) 

pred <- predict(model,TestData[testSlices[[1]],])

true <- TestData$All_Interactions[testSlices[[1]]]
}

#####
folds <- groupKFold(PerDay$ParticipantNumber, k = 7) 
ctrl <- trainControl(index = folds, method = 'cv')
z
train <- PerDay[folds[[1]],]
test <- PerDay[-folds[[1]],]

model <- train(formula, data=train, method="lm", na.action = na.omit) 


```

### OTHER: Random Intercept Regression Models
I only include variables that are overall correlated with the outcome of interest and not completly missing for some participants
```{r echo=FALSE}

#### Positive affect
formula <- as.formula(paste("pa_mean ~ Cluster_HOME_min + (Cluster_HOME_min | ParticipantNumber)"))


res_1h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "1h",  ])

res_3h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "3h",  ])
res_6h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "6h",  ])
res_9h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "9h",  ])
res_12h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "12h",  ])
res_24h_pa = lmer(formula,  data=Affect_Passive[Affect_Passive["timescale_beforeESM"] == "24h",  ])

stargazer(res_1h_pa,res_3h_pa,res_6h_pa,res_9h_pa,res_12h_pa,res_24h_pa, dep.var.labels.include	= T,type = "text")


### Calls
Call_index <- Affect_Passive %>%
          group_by(ParticipantNumber) %>%
          summarize(sum = sum(CALL_TOTAL_min))

Call_index <- Call_index$ParticipantNumber[Call_index$sum != 0]

formula <- as.formula(paste("pa_mean ~ CALL_TOTAL_min + (CALL_TOTAL_min | ParticipantNumber)"))

Affect_Passive_Call <- Affect_Passive[Affect_Passive$ParticipantNumber %in% Call_index,]

res_1h_pa = lmer(formula,  data=Affect_Passive_Call[Affect_Passive_Call["timescale_beforeESM"] == "1h",  ])

res_3h_pa = lmer(formula,  data=Affect_Passive_Call[Affect_Passive_Call["timescale_beforeESM"] == "3h",  ])
res_6h_pa = lmer(formula,  data=Affect_Passive_Call[Affect_Passive_Call["timescale_beforeESM"] == "6h",  ])
res_9h_pa = lmer(formula,  data=Affect_Passive_Call[Affect_Passive_Call["timescale_beforeESM"] == "9h",  ])
res_12h_pa = lmer(formula,  data=Affect_Passive_Call[Affect_Passive_Call["timescale_beforeESM"] == "12h",  ])
res_24h_pa = lmer(formula,  data=Affect_Passive_Call[Affect_Passive_Call["timescale_beforeESM"] == "24h",  ])

stargazer(res_1h_pa,res_3h_pa,res_6h_pa,res_9h_pa,res_12h_pa,res_24h_pa, dep.var.labels.include	= T,type = "text")

```


#### ADD: Point biserial Correlation between beeing alone and passive measures


#### Interaction & Passive Measure

```{r echo=FALSE}
Feature <- c('All_Interactions', "CLUSTER_HOME_pct")

Passive = c(
        'SOCIAL_APPS_pct',
        'APP_USAGE_pct',
        'APPS_OPENED_norm',
        'COMMUNICATION_APPS_pct',
        'CLUSTER_HOME_pct',
        'UNIQUE_STAYPOINTS_norm',
        'TIME_STATIONARY_pct',
        'TOTAL_MACHASHES_norm',
        'UNIQUE_MACHASHES_norm',
        'CALL_incoming_pct',
        'CALL_outgoing_pct',
        'CALL_TOTAL_pct',
        'MISSED_CALLS_norm'
      )

counter = 0
PerDay <- PerDay[!is.na(PerDay$ParticipantNumber),]
PerWeek <- PerWeek[!is.na(PerWeek$ParticipantNumber),]


for(j in 1:length(Passive)) {
  counter = counter + 1
  if (counter == 1) {
    CorPerDay <-
      data.frame(
        Passive = Passive[j],
        Time = "Per Day",
        "ParticipantNumber" = "Overall",
        "Correlation" = ifelse(
          sum(PerDay[, Passive[j]], na.rm = TRUE) != 0,
          as.numeric(cor.test(PerDay[, Feature[1]], PerDay[, Passive[j]])$estimate),
          NA
        ),
        "p.value" = ifelse(sum(PerDay[, Passive[j]], na.rm = TRUE) != 0, round(cor.test(
          PerDay[, Feature[1]], PerDay[, Passive[j]]
        )$p.value,2), NA)
      )
    
    CorPerWeek <-
      data.frame(
        Passive = Passive[j],
        Time = "Per Week",
        "ParticipantNumber" = "Overall",
        "Correlation" = ifelse(
          sum(PerWeek[, Passive[j]], na.rm = TRUE) != 0,
          as.numeric(cor.test(PerWeek[, Feature[1]], PerWeek[, Passive[j]])$estimate),
          NA
        ),
        "p.value" = ifelse(
          sum(PerWeek[, Passive[j]], na.rm = TRUE) != 0,
          round(cor.test(PerWeek[, Feature[1]], PerWeek[, Passive[j]])$p.value,2),
          NA
        )
      )
  } else{
    CorPerDay <- rbind(
      data.frame(
        Passive = Passive[j],
        Time = "Per Day",
        "ParticipantNumber" = "Overall",
        "Correlation" = ifelse(
          sum(PerDay[,Passive[j]], na.rm = TRUE) != 0,
          as.numeric(cor.test(PerDay[, Feature[1]], PerDay[, Passive[j]])$estimate),
          NA
        ),
        "p.value" = ifelse(sum(PerDay[, Passive[j]], na.rm = TRUE) != 0, round(cor.test(
          PerDay[, Feature[1]], PerDay[, Passive[j]]
        )$p.value,2), NA)
      ),
      CorPerDay
    )
    
    CorPerWeek <-
      rbind(
        data.frame(
          Passive = Passive[j],
          Time = "Per Week",
          "ParticipantNumber" = "Overall",
          "Correlation" = ifelse(
            sum(PerWeek[, Passive[j]], na.rm = TRUE) != 0,
            as.numeric(cor.test(PerWeek[, Feature[1]], PerWeek[, Passive[j]])$estimate),
            NA
          ),
          "p.value" = ifelse(
            sum(PerWeek[, Passive[j]], na.rm = TRUE) != 0,
            round(cor.test(PerWeek[, Feature[1]], PerWeek[, Passive[j]])$p.value,2),
            NA
          )),
          CorPerWeek
        )
    
    
  }
  
}


Correlation = rbind(CorPerDay, CorPerWeek)



Correlation$sign = "non-sign"
Correlation[!is.na(Correlation$p.value) &
              Correlation$p.value <= 0.05,]$sign = "sign"

Correlation$star = ""
Correlation[!is.na(Correlation$p.value) &
              Correlation$p.value <= 0.05,]$star = "*"


cor1 =  ggplot(Correlation,
               aes(
                 y = as.factor(Passive),
                 x = as.factor(Time),
                 fill = Correlation
               )) +
  geom_tile() +
  scale_fill_gradient2(low = "#D7191C", mid = "white", high = "#2C7BB6") +
  geom_text(aes(label = star), color = "black", size = 4) +
  ylab("") +
  xlab("") +
  ggtitle(paste("Correlation", Feature[1], "& Passive Features")) +
  theme_minimal()

ggplotly(cor1)
```


